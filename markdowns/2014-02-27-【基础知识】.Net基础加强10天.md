---
layout: post
title:  "【基础知识】.Net基础加强10天"
date:   2014-02-27 01:37:00
author:     "郝喜路"
header-img: "//static.haoxilu.net/post-bg.jpg"
tags:
    - 默认
---
一、 复习

1. 委托是类型，还是一种引用类型。

2. 使用委托的时候必须new一个委托对象。即便看到代码中没有new委托对象，编译器也会在编译的时候帮我们new赋值给委托的方法，其实是存储在委托对象中的。

3. 使用委托的步骤：

1\> 定义一个委托类型：public delegate voi d 委托的名称(参数列表);

2\> 声明一个委托变量:委托名称wd = new委托名称(方法名称);

3\> 调用委托：

在调用委托之前需要判断一下是否为空

If (wd !=null)

{

//开始调用委托

Wd();或者wd.Invoke();

}

4. 委托的作用：

当一个类型中需要嵌入一段代码，但是这段代码具有不确定性，是根据使用这个类型的用户来确定代码的，这种情况下就可以在该类型中使用一个委托，保证在某种情况下会调用这个方法。（简述：在一段代码中动态添加一个方法。）

自定义控件是的事件会大量用到委托。（些事件的时候用到委托）

/.、可以把静态方法或私有方法赋值给委托变量，赋值后只要能使用到该委托变量的地方就能使用该方法。打破了访问修饰符的限制。

二、 多播委托

1. 多播委托中方法调用的顺序与增加方法时的顺序是一致的，但是不要依赖于这个顺序。

微软并没有承诺一定是按这种顺序。

2. 多播委托中，如果要是有返回值，只会得到最后一个方法调用的返回结果。

3. 多播委托获取返回值：

a) 通过遍历，调用委托中的每个方法，实现获取每个方法的返回值。

b) 通过调用GetInvocationList()方法，返回当前委托中的所有方法，返回值类型是一个Delegate数组（委托数组）

c) 多播委托内部是将绑定在当前委托对象上的每个方法，都转换为一个委托对象，并且存储在了一个叫\_invocationLIst的object 数组中。

d) 然后当调用委托的时候，其实就是循环遍历\_invocationList数组，并且调用其中的每一个委托。

4. 多播委托中如果其中一个方法执行是发生异常时，则后续方法不执行。

5. 去掉一个方法，md = md – m4;

6. 使用多播委托时，如果不是用+=而是直接使用=赋值，会将前面绑定的所有方法（委托）覆盖掉。

7. 委托的不可变性：

a) 委托有类似于string的不可变性

b) [![wps_clip_image-10979](http://images.cnitblog.com/blog/578906/201402/270936523492334.png "wps\_clip\_image-10979")](http://images.cnitblog.com/blog/578906/201402/270936515619988.png)

8. 建议使用的时候尽量少定义委托自己的委托，尽量使用系统中已经有的委托。减少程序集中定义的类型的个数。

9. 委托的一些应用:

a) 多线程

b) 自定义类(控件/通信类/(事件))

c) 正则表达式中替换Email掩码

三、 事件

1. 通过委托实现事件的功能的问题;（因此不用委托而用事件）

a) 可以在类的外部触发。因为委托变量访问修饰符是public 的，所以在任何地方都可以触发。 如果把委托变量的访问修饰符改成private 的。那么的确不能在外部触发了，但是也不能在外部赋值了。

b) 由于委托可以使用等号来赋值，所以就有可能将前面所有已经注册的事件处理程序覆盖掉。

2. 什么事件？

a) 在使用事件之前必须定义委托，否则无法使用事件。

b) 定义了委托类型之后开始使用事件：public event 委托类型 m;

3. 使用事件的好处：

a) 因为事件只能通过+=或者-=来赋值，所以避免了使用=赋值覆盖的问题。

b) 事件不能在定义事件的类的外部触发，只能在那个类内部触发。所以也就避免了冒充事件触发的问题。

4. 事件就是一个私有的委托变量和两个共有的方法Add和Remove，分别是来实现事件的+=和-=

[![wps_clip_image-12372](http://images.cnitblog.com/blog/578906/201402/270936541089135.png "wps\_clip\_image-12372")](http://images.cnitblog.com/blog/578906/201402/270936535793806.png) [![wps_clip_image-27360](http://images.cnitblog.com/blog/578906/201402/270936552211107.png "wps\_clip\_image-27360")](http://images.cnitblog.com/blog/578906/201402/270936546986249.png)

四、 委托和事件的区别（常考）

1. 委托和事件没有可比性，因为委托是类型，事件是对象（可以理解为对委托变量的封装。d），下面说的是委托的对象（用委托方式实现的事件）和（标准的event方式实现）事件的区别。事件的内部是用委托实现的。（举例子：三种实现事件方式的区别）

2. 因为对于事件来讲，外部只能“注册自己+=、注销自己-=”，外界不可以注销其他的注册者，外界不可以主动触发事件，因此如果用Delegate就没法进行上面的控制，因此诞生了事件这种语法。add、remove。

3. 事件是用来阉割委托实例的。事件只能add、remove自己，不能赋值。事件只能+=、-=，不能=、不能外部触发事件。

五、 程序集(Assembly)

1. 只是在.net中的概念。.net中exe和dll 都是程序集。（exe和dll的区别：exe包含主函数可以被执行，dl不包含主函数，不可执行）

2. 程序集包含：类型元数据(描述在代码中定义的每一类型和成员,二进制形式)、程序集元数据（程序集清单、版本号、名称等）、IL代码(这些都被装在exe或dll中)、资源文件。每个程序集都有自己的名称、版本等信息。这些信息可以通过AssemblyInfo.cs文件来自己定义。

六、 反射

1. Type类

[![wps_clip_image-17811](http://images.cnitblog.com/blog/578906/201402/270936570234394.png "wps\_clip\_image-17811")](http://images.cnitblog.com/blog/578906/201402/270936561147250.png)

课后小项目：&nbsp;

[记事本+插件开发](http://pan.baidu.com/s/1dDId1ux "记事本+插件开发")，这是我根据本课内容写的小程序。

2014年2月27日09:41:23 &nbsp; 郝喜路&nbsp;

&nbsp;

