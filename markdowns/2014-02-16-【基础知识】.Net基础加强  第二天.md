---
layout: post
title:  "【基础知识】.Net基础加强  第二天"
date:   2014-02-16 01:27:00
author:     "郝喜路"
header-img: "//static.haoxilu.net/post-bg.jpg"
tags:
    - 默认
---
第02天 .Net基础加强

1、 封装

1\> 属性的封装：

属性封装字段：把变化封装一下，保留用户的使用方式

2\> 把方法的多个参数封装成一个对象

3\> 将一堆代码封装到一个方法中

4\> 将一些功能封装到几个类中

5\> 将一些具有相同功能的代码封装到了一个程序集中（dll、exe），并且对外提供统一的访问接口。（属性名、方法名等。）

2、 继承(:表示继承)

1\> Base Class à 基类 Parent Class à 父类

2\> Derived Classà 派生类 Child Class à 子类

3\> 好处：提高代码的重用性；多态

4\> 继承的特性

a\> 继承的单根性:只能继承一个父类

b\> 继承的传递性：子类继承父类是同时继承了父类从他的父类中继承的属性、字段和方法

6\> C#任何一个类都默认继承自Object类，如果一个类没有继承任何类，则默认继承Object类。如果继承了一个类，则将覆盖默认继承的Object类。

3、 继承中的构造函数▲

1\> 继承的时候，构造函数不能被继承。

2\> 子类的构造函数会默认去调用父类中的无参数的构造函数。

3\> 如果父类中没有无参数的构造函数，子类继承父类时会报错的，解决方案：

方案一： 在父类中增加一个无参数的构造函数。这时子类的构造函数就可以找到父类中的无参构造函数了。

方案二： 不修改父类，而是在子类中的构造函数后面通过:base(),显示去调用父类的某个构造函数，而不去调用无参的构造函数。

4、 通过this调用构造函数

作用：

1\> 在当前类的构造函数后面通过:this()来调用当前类自己的其他构造函数。

public Person(string name) : this(string name,0,0，null){}

5、 对象初始化器(语法糖)

Person p = new Person(){Name=”yzk”,Age=18,Email=”yzk365@qq.com”}

6、 集合初始化器

List\<int\> list = new List\<int\>(){10,20,30,40}

7、 通过this和base调用类的成员

在一般情况下，如果子类继承了父类的成员。那么在子类中，通过this.成员或base.成员都是访问的是一样的。

除非父类中的成员子类继承后又重写了。

8、 五种常用的访问修饰符

1\> private:私有的，只能在当前类内部来使用

2\> protected：受保护的，只能在当前类内部，以及所有当前类子类的内部。

3\> internal：只能在当前程序集内部访问，跨程序集是不能访问的

4\> protected internal：相当于同时具有protected和internal的权限。可以在当前程序集或子类中（不同程序集也可以访问）访问。

5\> public：任何地方都能访问

6\> protected和internal没有可比性。protected是当前类内部与所有子类内吧可访问，而internal是在同一个程序集中可访问。 假如不在一个程序集中，但是依然存在继承关系，那么protected访问修饰符修饰类型依然可以访问。

9、 关于父类中私有成员的继承问题

（私有字段到底是有没有继承，这是一个有很大分歧的问题！！）

我认为子类并不能继承父类的私有属性和字段

10、 访问级别的约束(类的访问修饰符只有两种，一种是public 另一种是internal。如果什么都不写，默认是internal)

1\> 子类的访问级别不能比父类的高（如果比父类的访问级别高的话，会暴露父类的成员）

2\> 方法的参数和返回值类型必须与方法本身的访问修饰符一致

3\> 属性的访问级别和属性的类型的访问级别（类的访问修饰符和类属性或字段的访问修饰符都高于【参数】的访问修饰符）

以上三种用于解决访问级别不一致的错误

11、 通过虚方法（virtual修饰）实现多态

1\> 虚方法，virtual：是虚方法的时候，那么这个方法的子类中就可以被重写(override)了.当子类继承父类后，可以直接使用该方法，也可以将该方法重写。

2\> 子类如果要重写父类中的方法，则需要在子类的Show方法前加一个override关键字。 子类重写父类的方法必须并且只能用override关键字。 此时，如果在子类中用this来调用则调用的是子类重用后的Show方法，如果在子类中用base来调用，则调用的依旧是父类中的Show方法。

3\> 虚方法可以给父类中的方法一个实现，比如ToString()方法

虚方法必须有实现部分，哪怕是空实现。

12、 多态（为了保护程序的可扩展性）：多态就是多种表现形态。

1\> 开放封闭原则（对修改封闭，对扩展开放）

2\> 多态就是指不同对象收到相同消息时，会产生不同行为，同一个类在不同的场合下表现出不同的行为特征。

3\> 多态的作用：把不同的子类对象都当做父类来看，可以屏蔽不同子类对象之间存在的差异，写出通用代码，做出通用的编程，以适应需求的不断变化。

13、 静态成员-静态类 static

1\> 调用静态方法的时候必须通过类名来直接调用，不能通过对象来调用。 也就是说，使用静态成员不需要实例化对象。

2\> 静态成员会在整个应用程序退出时，才会释放资源，所以可以在整个应用程序中共享数据。

3\> 静态类不能被实例化。不能被继承。

4\> 由于静态成员会在整个程序退出时，才释放资源，所以尽量避免写静态字段和静态属性，最好只写静态方法。

5\> 当给一个普通类添加静态字段后，系统会默认为该类生成静态构造函数【静态构造函数不能有访问修饰符、并且不能带参数】

6\> 静态类的构造函数，只会在第一次使用静态类之前，执行，并且只会执行一次。 静态构造函数不能有访问修饰符，不能有参数。

7\> 静态类不能多态。

8\> 什么时候使用静态类和静态成员

a\>什么情况下要将一个类标记为静态类

一般情况下是，当这个类是一个工具类，里面都是方法。为了让用户调用的时候方便，不需要实例化对象，这是可以给该类标记为static类（静态类），此时该类中只能包含静态成员不能包含实例成员。比如：Convert、Math、File、Console….

b\>什么情况下需要在一个普通类中编写一个静态成员，而这个类不能标记为static

当这个类需要别实例化的时候，如果这个类中有一个成员是所有对象都共享的数据，这是可以 将该类中的成员标记为静态的，但是这个类还是一个实例类。

14、 静态类的补充—密封类 (sealed关键字)

1\> 作用：

a\> 不能被继承

b\> 不能被重写

2\> 是一个密封类，不能被继承

3\> Sealed关键字，表示类不能被继承

4\> 密封类表示不能别继承。String类。.Net系统中本身对字符串有很多特殊处理（为String开了很多“绿灯”，String有很多特权，比如：不可变性，字符串池等等…），防止别的类继承后照成混乱。商业问题。

5\> 禁止子类重写父类的方法。

