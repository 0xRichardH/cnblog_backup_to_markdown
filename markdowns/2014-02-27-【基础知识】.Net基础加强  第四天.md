---
layout: post
title:  "【基础知识】.Net基础加强  第四天"
date:   2014-02-27 01:23:00
author:     "郝喜路"
header-img: "//static.haoxilu.net/post-bg.jpg"
tags:
    - 默认
---
一、 显示实现接口

1、 显示实现接口的目的：为了解决法方法重名的问题。

2、 显示实现接口必须是私有的，不能用public

3、 （复习）类中成员不写访问修饰符默认是private；类如果不写访问修饰符默认是internal

二、 接口的总结

1. 接口是一种规范。为了多态。

2. 接口不被实例化。

3. 接口中的成员不能加“访问修饰符”，接口中的成员访问修饰符为public,不能修改。（默认为public）

4.接口中的成员不能有任何实现（“光说不做”，只是定义了一组未实现的成员）。

5.接口中只能有方法、属性、索引器、事件，不能有“字段”。

6.接口与接口之间可以继承，并且可以多继承。

7.实现接口的子类必须实现该接口的全部成员。

8.一个类可以同时继承一个类并实现多个接口，如果一个子类同时继承了父类A，并实现了接口IA,那么语法上A必须写在IA的前面。class MyClass:A,IA{}，因为类是单继承的。

9.当一个抽象类实现接口的时候，如果不想把接口中的成员实现，可以把该成员实现为abstract。(抽象类也能实现接口，用abstrac标记)。（解释：子类可以在实现接口的时候吧接口中的方法实现为virtual或者abstract的类型。）

10.“显示实现接口”，只能通过接口变量来调用（因为显示实现接口后成员为private）。

三、 有关接口的使用建议

面向抽象编程，使用抽象(父类、抽象类、接口)不使用具体。

“向上转型”

在编程时：

接口→抽象类→父类→具体类（在定义方法参数、返回值、声明变量的时候能用抽象就不要用具体。）

能使用接口就不用抽象类，能使用抽象类就不用类，能用父类就不用子类。

避免定义“体积庞大的接口”、“多功能接口”，会造成“接口污染”。只把相关联的一组成员定义到一个接口中（尽量在接口中少定义成员）。单一职责原则

定义多个职责单一的接口（小接口）（组合使用）。（印刷术与活字印刷术）

随着学习的深入再继续体会接口的作用。

四、 枚举—普通枚举

1. 在普通枚举中，枚举值是互斥的。

2. 枚举中的每个值都有对应的数值来表示。

2.1 默认数值是整型int，从0开始，依次递增

2.2 可以手动设置每个枚举对应的整数

3. 枚举在编译完成后就已经用对应的数值常量来表示了。

4. 默认枚举都是使用int来替代的，但是也可以指定具体的数据类型。

枚举：byte（public enmu UserState : byte{}）表示，限制类枚举中的数字类型。

五、 枚举—标志枚举

1. 标志枚举是可以组合的。

2. 标志枚举的方式

[Flags]//看加Flags特性后，标志枚举的ToString()返回结果

public enum GoodPeople

&nbsp;&nbsp;&nbsp; {

高 = 1,

富 = 2,

帅 = 4,

白 = 8,

美 = 16,

优秀男 = GoodPeople.高 | GoodPeople.富 | GoodPeople.帅,

优秀女 = GoodPeople.白 | GoodPeople.富 | GoodPeople.美

&nbsp;&nbsp;&nbsp; }

3. 判断当前值中是否包含V1： 枚举 mj=…;&nbsp;&nbsp; if(mj&枚举.V1==枚举.V1)表示存在V1

六、 结构体

1. 在没有面向对象的类之前是用结构体来模拟的，进行给变量赋值

2. 结构与类最大的区别：结构是值类型，类是引用类型

3. 结构体不能继承但是可以实现接口

4. 什么时候使用结构体

4.1 如果需要面向对象的特征，如果存储量比较大&nbsp; →&nbsp; 使用类

4.2 如果存储的数据量比较小，不需要面向对象的特征 → 使用结构体

七、 类型转换

类型转换Cast是在内存级别上的转换。内存中的数据没有变化，只是观看的视角不同而已

1. 隐式类型转换：1\>把子类类型赋值给父类类型的时候发生隐式类型转换；2\>.将占用字节数小的数据类型赋值给占用字节数大的数据类型可以发生隐式类型转换（前提是这两种数据类型在内存的同一个区域。）

2. 当实在不知道应该怎么进行类型转换的时候就到Convert

3. 显示类型转换：

八、 值类型和引用类型

1. 值类型：

int、char、double、float、long、short、byte、bool、enum、struct、decimal

2. 引用类型：

string、数组、类（子定义数据类型）、接口、委托、

3. 所有的引用类型都继承自Object；所有的值类型都继承自System.ValueType，而System.ValueType又继承自Object

4. 值类型和引用类型作为参数传递（值传递）

5. 值类型和引用类型作为参数传递（引用传递）

5.1 ref表示按照引用传递

6. 值传递：传递的是栈中的内容；ref引用传递：传递的是栈本身的地址。

7. 对于值类型来说：栈中存储的就是直接使用的数据；对于引用类型来说：栈中存储的是堆中的对象。

8. 参数传递的时候：

8.1 值传递，传递的是栈中保存的数据；

8.2 引用传递，传递的是栈本身的地址。

九、 异常处理

1.&nbsp; 1.1 语法错误：语法错误一般编译器会帮我们解决

1.2 逻辑错误：编译和执行没有问题就是结果不对，一般是因为自己写错了。

1.3 异常：在运行时发生错误。异常一般会导致程序崩溃。

2. 如何进行异常处理？

2.1 try … catch … finally 进行异常处理

&nbsp;&nbsp; 把可能出现异常的代码用try块包围起来

&nbsp; 在try中，程序发生异常后，后直接跳转到catch块中，当前代码后面的代码都不执行了。

在catch块中，只有当程序发生异常后才会执行，如果程序不发生异常，则不执行catch块中的代码。

Finally代码块中的代码无论是否发生异常，都会被执行。finally中的代码会在异常发生崩溃前执行（就算没有捕获到异常也会执行）。即便在catch块中有return还是会执行的。

3.&nbsp; 异常处理有多种形式

3.1&nbsp;&nbsp; try{ … }catch{… }&nbsp;&nbsp; 可以捕获所有异常

3.2&nbsp; try { … } catch(Exception ex){… } 也可以将所有的异常进行捕获，并且可以将异常信息打印出来。

3.3 try{… }catch(XXXException ex){….}&nbsp; xxxx中的内容不同可以捕获不同的异常，

4. Exception 类的主要属性：Message、StackTrace、InnerException

5. 扔出自己的异常，扔：throw，抓住：catch

6. 抛出异常：

throw; 只能在catch块中使用。

throw new Exception(“需要抛出的异常信息”);可以在程序的任意地方使用这个抛出自己需要的异常。

7. 老师的建议：

尽量通过逻辑判断（if-else）减少异常发生的可能性！异常处理过多会降低程序的性能。

在多级方法嵌套调用的时候，如果发生了异常，则会终止所有相关方法的调用，并且释放相关的资源。

十、 可变参数params

1. 可变参数可以传一个参数，也可以传多个参数，也可以不传参数。

如果不为可变参数传值，则可变参数的数组是一个长度为0的数组，但是不是null。

2. 当一个方法中有多个参数时，并且包含可变参数时，可变参数只能放在参数列表的最后。

3. 可变参数也可以传一个数组进来。

十一、&nbsp; ref和out

1. ref必须先初始化，因为是引用，所以必须先“有”，才能引用，而out则是内部为外部赋值，所以不需要初始化，而且外部初始化也没用。

2. 使用out参数的时候，没有必须为变量赋值，即便赋值了也没有意义，使用前还是会清空

在方法中必须为out参数赋值。否则报错。

